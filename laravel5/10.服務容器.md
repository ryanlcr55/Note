##服務容器（Service Container)   
容器可以讓我們很輕易地實現依賴反轉   

在使用容器前原本程式 :    
 ````
    // 通知類別
    class Notification {
        // 通知會員有新訊息
        public function noticeNewMessage() {
            $mail = new Mail();
            $mail->send();
        }   
        // 通知會員有新文章
        public function noticeNewArticle() {
            $mail = new Mail();
            $mail->send();
        }
    }
````    
    
此CLASS中, 每個方法都須使用 MAIL物件    
為了簡化我們可以將實體化物件搬到建構子去    
````
// 通知類別
class Notification {
    public $mail;

    public function __construct (Mail $mail) {
        $this->mail = $mail;
    }

    // 通知會員有新訊息
    public function noticeNewMessage() {
        $this->mail->send();
    }

    // 通知會員有新文章
    public function noticeNewArticle() {
        $this->mail->send();
    }
}
````    
由此可看出, 我們省略了每個方法都需要實體化MAIL物件的麻煩,
並且可以`實踐依賴注入`    
    
Laravel也提供了一個很方便的用法,使我們可以將程式改成以下範例: 
````
// 通知類別
class Notification {

    // 通知會員有新訊息
    public function noticeNewMessage(Mail $mail) {
        $mail->send();
    }

    // 通知會員有新文章
    public function noticeNewArticle(Mail $mail) {
        $mail->send();
    }
}
````    
    
但是在 Laravel 4 要注入類別之前，必須先在`Provider`中對類別名稱對 app 進行綁定，讓 Laravel 4 認得這個要注入的類別是什麼物件
````
App::bind('Mail', function($app)
{
    return new SomeEmailService;
});
````    
    
而在 Laravel 5 除了可以用這樣手動綁定類別的方式，也有提供強大的自動綁定功能，你不需要在 app 內事先定義所有的類別，當 Laravel 5 在 app 內找不到該類別的時候，就會自動找所有引入（include）的類別中有沒有此類別，自動進行注入綁定！
    
- - - 
參考資料 : https://kejyuntw.gitbooks.io/laravel-5-learning-notes/design-pattern/design-pattern-service-container.html