##使用REDIS在PHP上實踐樂觀鎖 (check-and-set)
當在有條件下新增或修改一組數據時, 通常需要經過`檢查(CHECK)`, 滿足條件後才執行更新(SET)的動作, 
而在通過`檢查`後與`更新`間, 若有人更動同一筆數據, 使更動後的數據無法滿足我們`檢查`的條件, 我們仍然會執行`更新`的動作, 這樣就會造成數據上的錯誤。    
為了避免以上的錯誤，我們可以通過`悲觀鎖` 與 `樂觀鎖`解決這個問題, 而redis可以很輕易的實踐`樂觀鎖`, 故我們現在就來實作所謂的`樂觀鎖`。    
樂觀鎖大部分基於紀錄數據版本的機制實踐, 即位數據新一個版本號, 讀取資料時紀錄版本號, 若更新時數據的版本號與讀取時所記錄的版本號不同, 則重新讀取一次資料, 並再記錄新的版本號, 直到成功儲存為止。   
而此機制常用於搶購與搶票等系統。
    
以下為實踐程式碼 :  
````
$redis = new redis();  
$result = $redis->connect('127.0.0.1', 6379);

//事務執行狀況
$success = false; 

//當事務執行失敗時重複執行
while (!$success) {
    // 監控已經銷售的數量(store) 
    $redis->watch('store');
    $store = $redis->get('store');

    if ($store <= 0) {
        //當庫存沒有時, 提醒並結束程式
        echo '已經售完了!';
        die();
    };
    
    //開始事務
    $redis->multi();
    $redis->decr('store');
    $redis=>hset('older_list', 'user_id' . $userID);
    $success = $redis->exec();
}

echo '購買成功!';
die();
````